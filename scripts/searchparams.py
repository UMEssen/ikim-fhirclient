"""
The script takes a FHIR CapabilityStatement JSON file as input and generates TypeScript type definitions
for search parameters. It creates:
- Common search parameters that apply to all resources
- Resource-specific search parameters
- Type-safe parameter definitions based on FHIR datatypes

Usage:
    python searchparams.py -i capability.json -o search-params.ts [-p @my-package/fhir] [-b PrefixName]
"""

import argparse
from enum import Enum
from typing import Any, override
from dataclasses import dataclass
import json
import re


class FhirDatatype(str, Enum):
    DATE = "date"
    REFERENCE = "reference"
    STRING = "string"
    NUMBER = "number"
    TOKEN = "token"
    URI = "uri"
    QUANTITY = "quantity"
    COMPOSITE = "composite"
    SPECIAL = "special"

    def dump(self) -> str:
        if self == FhirDatatype.COMPOSITE or self == FhirDatatype.SPECIAL:
            return FhirDatatype.STRING.value
        else:
            return self.value


# implementations for python and ts need to match
# see
def camel_to_kebab(s: str) -> str:
    return re.sub(r"([a-z])([A-Z])", r"\1-\2", s).lower()


def kebab_to_camel(s: str) -> str:
    return re.sub(r"-([a-z])", lambda x: x.group(1).upper(), s)


@dataclass
class ParamEntry:
    name: str
    fhir_type: FhirDatatype


@dataclass
class ResourceEntry:
    resource_type: str
    entries: list[ParamEntry]


@dataclass
class ParseResult:
    common_params: list[ParamEntry]
    resources: list[ResourceEntry]


def parse_param(data: dict[str, str]) -> ParamEntry:
    return ParamEntry(name=data["name"], fhir_type=FhirDatatype(data["type"]))


def parse_resource(data: dict[str, Any]) -> ResourceEntry:
    return ResourceEntry(
        resource_type=data["type"],
        entries=[parse_param(sp) for sp in data.get("searchParam") or []],
    )


def parse(data: dict[str, Any]) -> ParseResult:
    rest = data["rest"]
    assert len(rest) == 1, "unsupported multiple rest modes"
    rest = rest[0]
    return ParseResult(
        common_params=unique_params([parse_param(sp) for sp in rest["searchParam"]]),
        resources=[parse_resource(res) for res in rest["resource"]],
    )


# in the example section of FHIR
# the search params are defined multiple times
# I assume this was a copy paste error
def unique_params(params: list[ParamEntry]) -> list[ParamEntry]:
    seen = set()
    acc = []
    for p in params:
        if p.name in seen:
            continue
        seen.add(p.name)
        acc.append(p)
    return acc


def read_file(path: str) -> dict[str, Any]:
    with open(path, "r") as f:
        return json.load(f)


def dump(output_path: str, parsed: ParseResult, import_path: str, basename: str):
    with open(output_path, "w") as f:
        f.write("// This file was autogenerated. Changes are futile!\n")
        dump_imports(f, import_path)

        overrides: dict[str, str] = {}
        dump_reference_types(f, parsed, basename)
        dump_common(f, parsed, basename, overrides)
        for res in parsed.resources:
            dump_resource(f, res, basename, overrides)
        dump_searchparam_struct(f, parsed, basename)
        if overrides:
            dump_overrides(f, overrides, basename)


def dump_imports(f, path_to_package: str):
    f.write(
        f"""
import type {{
    SearchParameter,
    SearchTypeDate,
    SearchTypeNumber,
    SearchTypeQuantity,
    SearchTypeReference,
    SearchTypeString,
    SearchTypeToken,
    SearchTypeUri,
}} from "{path_to_package}";\n\n"""
    )


# we need to determine whether a param needs an override
# idea:
#  c2k(k2c(n))  = n => no override needed
#  c2k(k2c(n)) != n => override needed
def dump_param(f, p: ParamEntry, basename: str, overrides: dict[str, str]):
    camel = kebab_to_camel(p.name)
    if p.name != camel_to_kebab(camel):
        overrides[camel] = p.name
    generic = f"<{basename}Types>" if p.fhir_type == FhirDatatype.REFERENCE else ""

    f.write(
        f"\t{camel}?: SearchParameter<SearchType{p.fhir_type.dump().capitalize()}{generic}>;\n"
    )


def dump_reference_types(f, parsed: ParseResult, basename: str):
    f.write(f"type {basename}Types =\n")
    for res in parsed.resources:
        f.write(f'\t|"{res.resource_type}"\n')
    f.write(";\n\n")


def dump_common(f, parsed: ParseResult, basename: str, overrides: dict[str, str]):
    f.write(f"export type {basename}All = {{\n")
    for sp in parsed.common_params:
        dump_param(f, sp, basename, overrides)
    f.write("}\n\n")


def dump_resource(f, res: ResourceEntry, basename: str, overrides: dict[str, str]):
    f.write(f"export type {basename}{res.resource_type} = {{\n")
    for sp in res.entries:
        dump_param(f, sp, basename, overrides)
    f.write(f"}} & {basename}All;\n\n")


def dump_searchparam_struct(f, parsed: ParseResult, basename: str):
    f.write(f"export type {basename} = {{\n")
    for res in parsed.resources:
        f.write(f"\t {res.resource_type}: {basename}{res.resource_type};\n")
    f.write("}\n\n")


def dump_overrides(f, overrides: dict[str, str], basename: str):
    f.write(f"export const {basename}Overrides = {{\n")
    for camel, override in overrides.items():
        f.write(f"\t'{camel}': '{override}',\n")
    f.write(f"}};\n")


parser = argparse.ArgumentParser("CapabilityStatement to SearchParameter definition")
parser.add_argument(
    "-i", "--input", required=True, help="Input path to CapabilityStatement json file "
)
parser.add_argument(
    "-o", "--output", required=True, help="Output path to typescript definition file "
)
parser.add_argument(
    "-p",
    "--import-path",
    required=False,
    help="Path to import types from",
    default="@ikim-ui/fhir-client",
)
parser.add_argument(
    "-b",
    "--basename",
    required=False,
    help="Basename to prefix type definitions",
    default="My",
)

if __name__ == "__main__":
    args = parser.parse_args()
    data = read_file(args.input)
    parsed = parse(data)
    dump(args.output, parsed, args.import_path, args.basename)
